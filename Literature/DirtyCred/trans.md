# DirtyCred：逐步提升Linux内核权限

## 摘要

内核漏洞DirtyPipe被报道称在Linux5.8以来的几乎所有版本都出现了。使用该漏洞，一个恶意行为可以在不触发已有的内核保护机制和漏洞缓解机制的情况下，实现逐步提升权限，使得该漏洞格外地令人不安。然而，DirtyPipe的成功很大程度上依赖于这个漏洞的能力——它通过Linux pipe注入数据到任意的文件中。这样一种能力在其他的内核漏洞中是很少见的，使得防御相对容易。只要Linux用户去除该漏洞，系统就能变得相对安全。

这项工作提出了一个新的利用方式——DirtyCred，它将其他的Linux内核漏洞推到DirtyPipe的层面(TODO:level)。从技术上说，给定一个Linux内核漏洞，我们的利用方式会交换非特权和特权的凭证(TODO:credentials)并因此提供<u>具有和DirtyPipe类似可利用性</u>的漏洞。通过这个可利用性，一个恶意行为则能够获得提升权限的能力，甚至从容器中逃逸。我们通过24个实际内核漏洞，在一个完全防护的Linux系统上评估了这个利用。我们发现DirtyCred能够在16个漏洞中体现可利用性，说明了DirtyCred的重要性。随着可利用性的评估，这项工作进一步提出一个新的内核防范机制。不像已有的Linux内核防范，我们新的防范机制<u>基于他们自己的权限</u> <u>在不重叠的内存区域</u>隔离了内核凭证对象(TODO:credential objects)。我们的实验结果显示出：新的防范机制主要引入了可忽略不计的开销。

## 关键词

操作系统安全；内核漏洞利用；权限提升

## 介绍

如今，Linux已经成为黑客喜爱的目标，因为Linux广泛应用于移动设备、云设施和web服务器。为了使Linux更加安全，内核开发者和安全专家引入了多种内核保护机制和漏洞利用缓解技术（比如KASLR和CFI），使得内核漏洞利用史无前例的困难。为了成功实现一个漏洞利用的目标，本文的恶意行为必须通过<u>漏洞禁用相关防护和缓解机制的能力</u>来鉴别强力的内核漏洞。

然而，一个最近的漏洞[CVE-2022-0847](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847)和它的利用方法正受到网络安全社区的高度重视。由于它的恶意行为和影响，它被标记了一个昵称——DirtyPipe。不像那些没有标记名称的内核漏洞，DirtyPipe的漏洞利用能够<u>不禁用内核保护和漏洞利用缓解机制</u>实现提权。这个特性导致已有的Linux防范机制失效并且因此导致许多Linux内核驱动的系统变得危险起来（比如安卓设备）。

虽然DirtyPipe功能强大，但它的漏洞利用和它的漏洞能力（例如，滥用Linux内核管道机制向任意文件注入数据）密切相关。对于其他的Linux内核漏洞来说，滥用管道的能力是几乎不被提供的。结果导致，Linux社区和设备制造商（如谷歌）的做法是迅速发行针对内核故障的补丁，从而消除攻击面(attack surface)。如果没有这个攻击面，这个漏洞利用对抗一个完全防御的Linux内核依然是困难的。对于其他的内核漏洞来说，想要造成和DirtyPipe一样的安全影响还是困难的。

> attack surface是指一系列漏洞点、向量和攻击方法的综合。

在这项工作中，我们呈现一个新颖的、通用的漏洞利用方式，通过它，即使是原始内核漏洞也能实现和DirtyPipe相同的漏洞利用目标。从技术的角度上看，我们的漏洞利用方式和DirtyPipe是不同的，它既不依赖于Linux的管道机制，也不依赖于CVE-2022-0847的漏洞特点。相反，它利用了一个堆内存破坏漏洞，将一个低权限的内核凭证对象替换成高权限。这种方法使得Linux内核误以为<u>一个非特权的用户能够获得操纵高权限文件或进程的许可</u>。因此，我们使用DirtyCred命名这个漏洞利用方式。

为了执行漏洞利用，DirtyCred需要处理三个关键的技术难点。首先，它需要将漏洞的功能转化为<u>一个有效的凭证对象交换</u>，因为不同类型的漏洞提供不同的内存破坏能力，第一眼看起来可能对于一个凭证对象交换是不充分的。第二，DirtyCred需要严格控制启动对象交换的时间窗口(TODO:time window)。我们会在第三部分讲到，给到DirtyCred的有效时间窗口是很短的。如果没有一个实际的机制去延长时间窗口的话，漏洞利用将变得不稳定。第三，DirtyCred需要找到一个有效的机制——允许非特权用户以主动的方式分配特权的凭证。因为如果没有这个能力，将导致凭据对象交换失效。

为了解决以上的技术难点，我们首先介绍一系列漏洞转化方案，以允许我们将基于堆的漏洞转换为<u>以无效方式释放凭证对象的能力</u>。第二，我们充分利用三个不同的内核特性——[userfaultfd](https://www.kernel.org/doc/html/latest/admin-guide/mm/userfaultfd.html)/[FUSE](https://www.kernel.org/doc/html/latest/filesystems/fuse.html)/文件系统锁，以此延长对象交换所需的时间窗口并使得漏洞利用稳定下来.最后，我们利用多种内核机制在用户空间和内核空间派生高权限线程，从而主动分配高权限对象。在这项工作中，我们通过使用24个实际内核漏洞来评估DirtyCred的漏洞利用。我们惊奇的发现，DirtyCred能在16个漏洞和容器逃逸中实现提权。我们分享新提出的漏洞利用方式到Google Vulnerability Rewards Program([kCTF VRP](https://security.googleblog.com/2022/02/roses-are-red-violets-are-blue-giving.html))并且收到了他们的确认和奖励。

根据强有力的演示证明和有效防范机制的缺乏，我们相信，如果Linux社区不立即采取措施并且部署新的防范机制的话，DiryCred不久之后将成为Linux的巨大威胁。根据我们新的漏洞利用方法，我们进一步的提出了一个新的Linux内核防范机制。这个防范机制的基本点是在非重叠内存区域中托管高权限和低权限对象。在这项工作中，我们利用vmalloc区域来存储高权限对象、利用普通区域来存储低权限对象，以实现上述任务。我们将这个防范机制作为一个Linux内核原型来实施，并且使用一个标准分支评估它的性能。我们表明我们的防御机制主要引入的是可忽略的开销。对于一些涉及文件的操作，它显示了适度的性能开销。

和其他现有的内核漏洞利用比较而言，DirtyCred有许多不同的特性。首先，它是一个通用的利用方法因为它能够在任意基于堆的漏洞中提权。第二，它可以大幅度减轻漏洞利用缓解的阻碍，因为对于DirtyCred来说，人们可以制作一个<u>可以完全不修改，从一个内核版本转移到另一个版本的漏洞利用</u>。第三，它可以绕过许多强力的内核保护机制和漏洞利用缓解机制（如CFI,KASLR,SMEP/SMAP,KPTI等）。最后，它可以超越提权，从而导致更多严重的安全问题，例如安卓提权和容器逃逸。

总结来说，这篇文章做出了以下贡献。
* 我们提出了一个新的、通用的漏洞利用方式——DirtyCred。它能够绕过广泛利用的内核保护机制和漏洞利用缓解机制，从而实现在Linux系统中提权。
* 我们表明DirtyCred可能在许多真实的Linux内核漏洞中展现出强大的可利用性。我们同时表明，DirtyCred可以使用的可利用对象是多种多样的。
* 我们分析现有的内核防御限制并提出一个新的防御机制。我们把这个防御机制当作Linux内核的原型来实施，表明它引入的是适度的性能开销。

