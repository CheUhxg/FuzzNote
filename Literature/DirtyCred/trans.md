# DirtyCred：逐步提升Linux内核权限

## 摘要

内核漏洞DirtyPipe被报道称在Linux5.8以来的几乎所有版本都出现了。使用该漏洞，一个恶意行为可以在不触发已有的内核保护机制和漏洞缓解机制的情况下，实现逐步提升权限，使得该漏洞格外地令人不安。然而，DirtyPipe的成功很大程度上依赖于这个漏洞的能力——它通过Linux pipe注入数据到任意的文件中。这样一种能力在其他的内核漏洞中是很少见的，使得防御相对容易。只要Linux用户去除该漏洞，系统就能变得相对安全。

这项工作提出了一个新的利用方式——DirtyCred，它将其他的Linux内核漏洞推到DirtyPipe的层面(TODO:level)。从技术上说，给定一个Linux内核漏洞，我们的利用方式会交换非特权和特权的证书(TODO:credentials)并因此提供<u>具有和DirtyPipe类似可利用性</u>的漏洞。通过这个可利用性，一个恶意行为则能够获得提升权限的能力，甚至从容器中逃逸。我们通过24个实际内核漏洞，在一个完全防护的Linux系统上评估了这个利用。我们发现DirtyCred能够在16个漏洞中体现可利用性，说明了DirtyCred的重要性。随着可利用性的评估，这项工作进一步提出一个新的内核防范机制。不像已有的Linux内核防范，我们新的防范机制<u>基于他们自己的权限</u> <u>在不重叠的内存区域</u>隔离了内核证书对象(TODO:credential objects)。我们的实验结果显示出：新的防范机制主要引入了可忽略不计的开销。

## 关键词

操作系统安全；内核漏洞利用；权限提升

## 介绍

如今，Linux已经成为黑客喜爱的目标，因为Linux广泛应用于移动设备、云设施和web服务器。为了使Linux更加安全，内核开发者和安全专家引入了多种内核保护机制和漏洞利用缓解技术（比如KASLR和CFI），使得内核漏洞利用史无前例的困难。为了成功实现一个漏洞利用的目标，本文的恶意行为必须通过<u>漏洞禁用相应防护和缓解机制的能力</u>来鉴别强力的内核漏洞。

然而，一个最近的漏洞[CVE-2022-0847](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847)和它的利用方法正受到网络安全社区的高度重视。由于它的恶意行为和影响，它被标记了一个昵称——DirtyPipe。不像那些没有标记名称的内核漏洞，DirtyPipe的漏洞利用能够<u>不禁用内核保护和漏洞缓解机制</u>实现提权。这个特性导致已有的Linux防范机制失效并且因此导致许多Linux内核驱动的系统变得危险起来（比如安卓设备）。

虽然DirtyPipe功能强大，但它的漏洞利用和它的漏洞能力（例如，滥用Linux内核管道机制向任意文件注入数据）密切相关。对于其他的Linux内核漏洞来说，滥用管道的能力是几乎不被提供的。结果导致，Linux社区和设备制造商（如谷歌）的做法是迅速发行针对内核故障的补丁，从而消除攻击面(attack surface)。如果没有这个攻击面，这个漏洞利用对抗一个完全防御的Linux内核依然是困难的。对于其他的内核漏洞来说，想要造成和DirtyPipe一样的安全影响还是困难的。

> attack surface是指一系列漏洞点、向量和攻击方法的综合。

在这项工作中，我们呈现一个新颖的、通用的漏洞利用方式，通过它，即使是原始内核漏洞也能实现和DirtyPipe相同的漏洞利用目标。从技术的角度上看，我们的漏洞利用方式和DirtyPipe是不同的，它既不依赖于Linux的管道机制，也不依赖于CVE-2022-0847的漏洞特点。相反，它利用了一个堆内存破坏漏洞，将一个低权限的内核证书对象替换成高权限。这种方法使得Linux内核误以为<u>一个非特权的用户能够获得操纵高权限文件或进程的许可</u>。因此，我们使用DirtyCred命名这个漏洞利用方式。

为了执行漏洞利用，DirtyCred需要处理三个关键的技术难点。首先，它需要将漏洞的功能转化为<u>一个有效的证书对象交换</u>，因为不同类型的漏洞提供不同的内存破坏能力，第一眼看起来可能对于一个证书对象交换是不充分的。第二，DirtyCred需要严格控制启动对象交换的时间窗口(TODO:time window)。我们会在第三部分讲到，给到DirtyCred的有效时间窗口是很短的。如果没有一个实际的机制去延长时间窗口的话，漏洞利用将变得不稳定。第三，DirtyCred需要找到一个有效的机制——允许非特权用户以主动的方式分配特权的证书。因为如果没有这个能力，将导致凭据对象交换失效。

为了解决以上的技术难点，我们首先介绍一系列漏洞转化方案，以允许我们将基于堆的漏洞转换为<u>以无效方式释放证书对象的能力</u>。第二，我们充分利用三个不同的内核特性——[userfaultfd](https://www.kernel.org/doc/html/latest/admin-guide/mm/userfaultfd.html)/[FUSE](https://www.kernel.org/doc/html/latest/filesystems/fuse.html)/文件系统锁，以此延长对象交换所需的时间窗口并使得漏洞利用稳定下来.最后，我们利用多种内核机制在用户空间和内核空间派生高权限线程，从而主动分配高权限对象。在这项工作中，我们通过使用24个实际内核漏洞来评估DirtyCred的漏洞利用。我们惊奇的发现，DirtyCred能在16个漏洞和容器逃逸中实现提权。我们分享新提出的漏洞利用方式到Google Vulnerability Rewards Program([kCTF VRP](https://security.googleblog.com/2022/02/roses-are-red-violets-are-blue-giving.html))并且收到了他们的确认和奖励。

根据强有力的演示证明和有效防范机制的缺乏，我们相信，如果Linux社区不立即采取措施并且部署新的防范机制的话，DiryCred不久之后将成为Linux的巨大威胁。根据我们新的漏洞利用方法，我们进一步的提出了一个新的Linux内核防范机制。这个防范机制的基本点是在非重叠内存区域中托管高权限和低权限对象。在这项工作中，我们利用vmalloc区域来存储高权限对象、利用普通区域来存储低权限对象，以实现上述任务。我们将这个防范机制作为一个Linux内核原型来实施，并且使用一个标准分支评估它的性能。我们表明我们的防御机制主要引入的是可忽略的开销。对于一些涉及文件的操作，它显示了适度的性能开销。

和其他现有的内核漏洞利用比较而言，DirtyCred有许多不同的特性。首先，它是一个通用的利用方法因为它能够在任意基于堆的漏洞中提权。第二，它可以大幅度减轻漏洞利用缓解的阻碍，因为对于DirtyCred来说，人们可以制作一个<u>可以完全不修改，从一个内核版本转移到另一个版本的漏洞利用</u>。第三，它可以绕过许多强力的内核保护机制和漏洞缓解机制（如CFI,KASLR,SMEP/SMAP,KPTI等）。最后，它可以超越提权，从而导致更多严重的安全问题，例如安卓提权和容器逃逸。

总结来说，这篇文章做出了以下贡献。
* 我们提出了一个新的、通用的漏洞利用方式——DirtyCred。它能够绕过广泛利用的内核保护机制和漏洞缓解机制，从而实现在Linux系统中提权。
* 我们表明DirtyCred可能在许多真实的Linux内核漏洞中展现出强大的可利用性。我们同时表明，DirtyCred可以使用的可利用对象是多种多样的。
* 我们分析现有的内核防御限制并提出一个新的防御机制。我们把这个防御机制当作Linux内核的原型来实施，表明它引入的是适度的性能开销。

## 背景和威胁模型

这部分介绍一些必需的技术背景，方便理解我们新提出的漏洞利用方式。并且，我们讨论我们的威胁模型和假设。

### Linux内核的证书

证书([credentials](https://www.kernel.org/doc/Documentation/security/credentials.txt))指的是一些能够包含权限信息的内核特性。通过这些特性，Linux内核能够检查用户的访问权限。在Linux内核中，证书作为带有权限信息的内核对象被实现。据我们所知，那些对象包括cred、file和inode。在本文中，我们只使用了cred和file对象来设计了我们的漏洞利用方式。我们排除了inode对象，因为它只有当一个新文件被创建的时候才会被分配，这样无法提供足够的灵活性以操作内存（这是在程序漏洞利用中的关键操作）。我们为了cred、file和inode提供了一些必要的背景如下。

每个Linux任务都包含一个指向cred对象的指针。该cred对象包含UID域，该域表明了该任务的权限。例如，GLOBAL_ROOT_UID表明该任务有管理员权限。当一个任务试图访问一个资源（例如文件）时，内核会检查该任务的cred对象的UID，从而决定该访问是否能够被授权。除了UID，cred对象还包含能力值(TODO:capability)，该能力指定该任务的细粒度特权。例如，CAP_NET_BIND_SERVICE表明该任务能够绑定套接字到因特网域的特权端口。对于每个任务来说，他们的证书是可配置的。当更改任务证书时，内核将遵循复制并替换(copy-and-replace)的原则。它首先拷贝证书。第二步，它修改拷贝。最后，它改变cred指针，使其指向刚修改的拷贝。在Linux中，每个任务都能更改它自己的证书。

在Linux内核中，每个文件都带着它所有者的UID、GID、能力值和其他用户的访问权限。对于可执行文件来说，他们还包含SUID/SGID的标志，表明允许其他用户以所有者的权限去运行。在Linux内核的实现中，每个文件都和一个链接着证书的inode对象绑定。当一个任务试图打开一个文件时，内核会在授予文件访问权限之前，调用inode_permision方法来检查inode和相应权限。在文件被打开后，内核将证书从inode对象上脱钩并且将证书附加到file对象上。除了维护证书，file对象也包含了文件的读写权限。通过file对象，内核能够索引到cred对象从而检查权限。并且它可以检查读写权限从而保证任务不会向一个只读模式的文件写入数据。

### 内核堆内存管理

Linux内核设计内存分配器来管理小内存分配，以此提升性能并避免碎片。尽管有Linux内核三个不同的内存分配器，但是它们都遵循相同的高级设计。具体点说，他们都使用缓存来维护相同大小的内存。对于每个缓存来说，内核分配内存页并且划分内存为多个相同大小的块，每个块都是用于托管对象的内存槽。当一个缓存的内存页消耗殆尽了，内核将会分配新的内存页给缓存。如果一个缓存不再使用内存页，换句话说就是，内存中的所有对象都被释放了，内核将立即回收这些内存页。Linux内核中主要有2种缓存，如下所述。

**通用缓存**。Linux内核有不同的通用缓存来分配不同大小的内存。当从通用的缓存分配内存时，内核首先将请求大小四舍五入并且找到匹配请求大小的缓存。然后它从相应的缓存分配一个内存槽。在Linux内核中，如果一个分配请求没有明确分配内存的缓存种类，本次分配默认发生在通用缓存。对于属于相同通用缓存的分配，他们可能共享相同的内存地址，因为它们在相同的内存页上维护。

**专用缓存**。Linux内核为了性能和安全的目的创建了专用缓存。当一些对象在内核中被频繁使用，为这些对象专门分配缓存能够减少内存分配的时间消耗，从而提升系统性能。专用缓存和通用缓存的内存分配不共享相同的内存页。因此通用缓存和专用缓存分配的对象不相邻，这可以看作是缓存级隔离，它缓解了通用缓存对象的溢出威胁。

### 威胁模型

在我们的威胁模型中，我们假设非特权用户有Linux系统的本地访问权限，以便于在内核中利用堆内存破坏漏洞，从而提升用户的权限。并且我们假设Linux支持上游内核中所有可用的漏洞缓解机制和内核保护机制，这些机制包括KASLR,SMAP,SMEP,CFI,KPTI等。有了这些缓解和保护机制后，实现了内核地址随机、内核在执行中不能直接访问用户空间内存并且保证了它执行流的完整性。最后，我们不假设有可以使内核利用更方便的硬件端通道。

