# 简介

DirtyCred是利用一些原始内核漏洞实现和DirtyPipe相同的效果。
* DirtyCred的利用方式不依赖于Linux的管道机制，而是利用**堆内存破坏漏洞**。
  * 堆内存破坏漏洞需要**将低权限的证书对象替换成高权限的**。
* Linux内核会误认为非特权用户拥有高权限对象的操作许可。

DirtyCred的*技术难点*：
1. 需要将普通漏洞**转换**为对证书对象的交换。
2. 需要为证书对象的交换**延长**时间窗口。
3. 需要让非特权用户能主动分配特权的证书对象。

针对技术难点的*解决方案*：
1. 提供一系列漏洞转换方案。
2. 利用三个内核特性延长时间窗口。
3. 利用多个内核机制派生高权限线程。

DirtyCred的防御方式：
* 在非重叠内存区域分别管理高/低权限对象。
  * 非重叠区域使用的是**虚拟内存**。
  * vmalloc存储高权限对象，kmalloc存储低权限对象。

DirtyCred的*特性*：
1. 是一个通用的漏洞，可以基于任意堆漏洞提权。
2. 很好的迁移性。
3. 能很有效的绕过漏洞防御。
4. 可以实现Android提权和容器逃逸。

# 背景

## Linux内核中的证书

[证书](https://www.kernel.org/doc/html/latest/security/credentials.html)指向一些包含权限信息的内核属性。
* 内核通过这些属性检查用户的访问权限。
* 证书作为<u>带有权限信息的内核对象</u>被实现。
* 这里只使用了**cred对象**和**file对象**。
  * inode对象只有在创建新文件时才会被分配==>不够灵活。

所有task都包含一个cred对象指针。
* cred对象包含的*UID域*，表明task权限。
  * GLOBAL_ROOT_UID：管理员权限。
* cred对象包含的*cap值*，表明task的细粒度权限。
  * CAP_NET_BIND_SERVICE：绑定套接字到因特网域特权端口的能力。
* cred对象遵循**copy-and-replace**的原则。

每个文件都带着它所有者的UID、GID、其他用户的访问权限和cap。
* 可执行文件的**SUID/SGID标志**，表明允许其他用户以所有者的权限运行。
* 每个文件都与一个链接着证书的inode对象绑定。
* 当一个task打开一个文件时，首先检查inode记录的权限；文件被打开后，内核**将证书从inode对象上脱钩并链接到file对象上**。
  * **通过file对象可以索引到cred对象**从而检查权限。

> struct task_struct和struct file都包含const struct cred*域。

## 内存管理

内核使用缓存来维护相同大小的内存。
* 每个缓存中，内核会分配内存页并划分为相同大小的内存块，每个内存块是寄放对象的内存槽。
* 缓存中内存页用完之后，内核会分配新的内存页；如果内核页上的对象都被释放，内核会回收该内存页并分配给其他缓存。

内核中主要有2种缓存。
* **通用缓存**
  * 如果分配请求没有明确分配内存的缓存种类，则默认在通用缓存中分配。
  * 属于相同通用缓存的分配，它们可能共享内存地址。
* **专用缓存**
  * 为一些频繁使用的对象专门分配缓存。
  * 专用缓存与通用缓存是隔离开的。

