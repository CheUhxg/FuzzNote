# 第二章 从内核出发

## 内核源码树

|目录|描述|
|--|--|
|arch|特定体系结构的源码|
|block|块设备IO层|
|Documentation|内核源码文档|
|drives|设备驱动程序|
|firmware|某些驱动程序需要的设备固件|
|fs|VFS和各种文件系统|
|include|内核头文件|
|init|内核引导和初始化|
|ipc|进程间通信代码|
|kernel|核心子系统（如调度程序）|
|lib|通用内核函数|
|mm|内存管理子系统和VM|
|net|网络子系统|
|samples|示范代码|
|scripts|编译内核所需脚本|
|security|安全模块|
|usr|用户空间代码|
|tools|开发工具|
|virt|虚拟化基础结构|

根目录下有些文本文件。
* COPYING：内核许可证（GNU GPL v2）。
* CREDITS：内核开发者列表。
* MAINTAINERS：内核子系统和驱动维护者列表。
* Makefile：基于内核的Makefile。

## 编译内核

### 配置内核

可以在编译内核之前，对源码进行配置。
* 可以配置以CONFIG_为前缀的选项，如CONFIG_SMP。
* 配置选项用于决定哪些文件编译进入内核，也可以通过预处理命令处理代码。

内核配置有如下方式：
``` bash
make config
make menuconfig
make gconfig
make defconfig
```

配置项会被保存在内核代码根目录下的.config文件中。
* 更改配置文件之后，更新配置操作：
``` bash
make oldconfig
```

> CONFIG_IKCONFIG_PROC把压缩过的内核配置文件存在/proc/config.gz中。
> 编译新内核时，可以使用zcat将其覆盖到.config文件中。

### 编译内核

内核配置好之后，直接使用make进行编译。

make默认只衍生一个作业，因为Makefiles常会出现不正确的依赖信息。
* 对于不正确的依赖，多个作业可能发生**相互踩踏**，导致编译出错。
* 但是内核Makefiles没有这样的错误，所以可以使用多作业编译。

### 安装内核

安装过程与**启动引导工具(boot loader)**有关。
* 将内核映像拷贝到指定的位置，并按照启动要求安装。
* 模块的安装是**独立于体系结构**的，使用`make install`就能将已编译好的模块安装到正确的主目录/lib/modules下。
* 编译时还会在根目录下创建一个System.map文件，该文件是**符号对照表**，将内核符号和它们的起始地址对应起来。

## 开发内核

开发内核的几个特殊点
* 不能访问C库，必须使用GNU C。
* 缺乏内存保护机制。
* 难以执行浮点运算。
* 每个进程只有一个**很小的定长堆栈**。
* 需要注意同步和并发（内核支持异步中断、抢占和SMP）。
* 需要可移植。

### 无libc库/无标准头文件

大部分的C库函数都已经在内核中实现了。
* 头文件位于内核源代码书根目录下的include目录中。

没实现的函数中，比如printf()，内核中的printk()可以代替。
* 不同点在于printk可以指定标志来设置优先级，以决定在何处显示该条消息。

### GNU C

Unix和Linux内核都是用C语言写的。
* 内核并不完全符合ANSI C标准。

内核代码使用到的C语言扩展
* 内联函数：inline的同时，需要使用static关键字，保证编译时不会为其单独建立函数体。
* 内联汇编：使用acm()指令嵌入汇编代码（必须知道对应体系结构）。
* 分支声明：如果一个条件**（不）经常**出现时，编译器可以对其进行优化。内核将该指令封装成了宏->likely()和unlikely()。

### 没有内存保护机制

用户程序非法访问内存时，内核会发现该错误并**发送SIGSEGV信号**。
* 内核中发生的内存错误会**导致[oops](https://wiki.ubuntu.com/DebuggingKernelOops)**。

> **内核中的内存都不分页**：用多少字节，物理内存就减少多少字节。

### 不轻易在内核中使用浮点数

用户空间的浮点数操作需要**由内核完成整数操作到浮点数操作的模式转换**。
* 内核本身无法陷入，需要手动保存和恢复浮点寄存器。

### 栈容量小并且固定

用户空间的程序栈很大还可以动态增长。
* 内核栈大小固定，具体取决于页面大小（内核栈大小=2页）。
* 每个处理器都有自己的内核栈。

### 同步和并发

内核很多特性都要求并发地访问数据，然而内核很容易产生**竞争条件**。
* Linux是**抢占多任务操作系统**。内核调度进程时必须和这些任务同步。
* Linux内核**支持对称多处理器系统(SMP)**。内核必须保证一个资源不会同时被两个及以上的处理器访问。
* **中断是异步到来的**。内核需要保证中断处理程序不会访问当前程序使用的资源。
* Linux内核可以**抢占**。内核需要保证相同的资源不会被几段代码同时访问。

### 可移植性的重要性

Linux内核的大部分C代码与体系结构无关。
* 保持字节序、64位对齐、不假定字长和页面长度。

## 参考

[Linux kernel oops](https://blog.csdn.net/rikeyone/article/details/103464572)