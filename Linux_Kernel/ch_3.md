# 第三章 进程管理

## 进程

进程就是处于执行期的程序。
* 进程=代码段+数据段+打开的文件+挂起的信号+内核内部数据+处理器状态+具有内存映射的内存地址空间+线程。

线程是进程中活动的对象。
* 每个线程都有一个独立的程序计数器、进程栈和一组进程寄存器。
* Linux的线程实现中**不区分线程和进程**，将线程视为特殊的进程。

进程提供两种虚拟机制。
* 虚拟处理器：让进程认为自己独占处理器。
* 虚拟内存：让进程认为自己拥有整个系统的所有内存资源。

> 线程之间可以共享虚拟内存，但是虚拟处理器独立。

Linux系统使用fork()派生新进程。
* fork()返回两次：分别回到父进程和子进程。
* fork()实际上是由clone()系统调用完成的。

一个进程退出后进入**僵死状态**，直到其父进程调用wait()或waitpid()。

## 进程描述符

内核将进程的列表放在**任务队列**中。
* 任务队列是一个**双向循环链表**，链表节点的类型是task_struct，被称作进程描述符。
* task_struct在linux/sched.h中被定义，包含了**内核管理一个进程所需的所有信息**。

### 分配进程描述符

Linux使用**slab分配器**分配task_struct结构。
* 这是为了达到**对象复用**和**缓存着色**的目的。
* slab分配器动态生成task_struct，即**在内核栈的尾端自高向低创建一个新的thread_info结构体**，其中会包括进程描述符的地址。

### 进程描述符的存放

内核通过一个唯一的PID来标识每个进程。
* PID是一个数，类型为pid_t（实际上就是int），默认最大值为32768。
* PID放在各自的进程描述符中。
* 最大值可以通过/proc/sys/kernel/pid_max来修改。

内核访问任务需要获得指向其task_struct的指针。
* 内核通过current宏查找当前运行进程的进程描述符，所以这个过程的速度很重要。
  * 有的体系结构可以给出专门的寄存器来存放进程描述符的指针。
  * x86寄存器不够，只能通过偏移间接计算task_struct结构的地址。

### 进程状态

进程描述符中的state字段表示了进程当前的状态。
* TASK_RUNNING（运行）——进程在等待执行或者正在执行中。
  * 用户空间中的进程只有这一种状态。
* TASK_INTERRUPTIBLE（可中断）——进程正在阻塞中。
  * 进程获得所需条件后，内核会将其状态设置为TASK_RUNNING。
  * 同时进程接收到信号被唤醒。
* TASK_UNINTERRUPTIBLE（不可中断）——大致同TASK_INTERRUPTIBLE。
  * 区别在于，该状态接收到信号也不会被唤醒。
  * 常用于*等待不受干扰*和*等待条件很快发生*的情况。
* __TASK_TRACED（跟踪）——被其他进程跟踪。
  * 例如：ptrace跟踪对应进程。
* __TASK_STOPPED（停止）——进程已停止执行。
  * 进程无法再重新投入运行。
  * 通常是接收到了SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU信号，或者是在调试期间接受到任何信号。

### 设置当前进程状态

使用`set_task_state(task, state)`函数。
* 该函数将task的状态设置为state。
* 在SMP系统中，必要的时候，该函数会设置**内存屏障**来强制其他处理器**重新排序**。
* `set_current_state(state)`雷同。

> 函数在linux/sched.h中。

### 进程上下文

可执行程序代码从可执行文件中**载入到进程的地址空间**，这个过程一般在**用户空间**执行。

程序执行了系统调用/触发了异常时，进程会陷入内核空间。
* 此时，内核**代替进程执行**并**处于进程上下文中**，在此上下文中current宏是有效的（除非被调度了）。
* 内核退出时，程序会在用户空间恢复执行。

### 进程家族树

所有进程都是PID为1的init进程后代。
* 内核**在系统启动的最后阶段**启动init进程。
* init进程读取系统的初始化脚本(initscript)并执行其他相关程序。
* init进程的进程描述符是静态分配的，称作init_task。

每个进程都必有一个父进程。
* 进程的子进程通过children的子进程链表管理。
* 进程的父进程通过parent指针记录。