# 第四章 进程调度

调度程序是**确保进程能有效工作的内核子系统**。
* 调度程序决定哪个进程投入运行、何时运行以及运行的时长。
* 调度程序是Linux系统的基础，才能实现多进程并发。

## 多任务

多任务就是能同时并发多个进程的操作系统。

多任务系统分为两类：非抢占式多任务和抢占式多任务。
* **Linux是抢占式多任务**。

进程若不被抢占，其能够运行的时间是预设好的，称作**时间片**。
* 这样可以避免个别进程独占系统资源以及便于调度程序管理。
* 现在很多操作系统**采用动态时间片计算**的方式。
  * Linux并**没有采取时间片**的方式来达到公平调度。

非抢占式多任务模式中，除非进程主动停止，否则它会一直执行。
* 让步(yielding)：进程主动挂起自己。
* 如果出现不让步的进程就容易导致其他进程永远无法执行。

## Linux的进程调度

Linux采用叫做**O(1)调度器**的调度程序。
* 主要依赖**静态时间片算法**和**针对每一个处理器的运行队列**。
* O(1)调度器在多处理器环境下运行完美，但是调度响应时间敏感的程序却有缺陷。
  * 交互进程：时间敏感的程序。

为提高对交互程序的调度性能，引入了“**反转楼梯最后期限调度算法**”(RSDL)。
* 该算法吸取了**队列理论**，将**公平调度**的概念引入了Linux调度程序。
* 替代O(1)之后，它被称为**完全公平调度算法**(CFS)。

> 本章主要介绍完全公平调度算法，也会介绍O(1)。

## 策略

策略可以决定调度程序何时让什么进程运行。
* 还要负责优化使用处理器时间。

### I/O消耗型和处理器消耗型的进程

进程可以分为I/O消耗型和处理器消耗型。
* I/O消耗型：进程大部分时间用来提交或者等待I/O请求。
  * 常处于可运行状态，大部分时间都在阻塞，运行时间少。
* 处理器消耗型：进程大部分时间都执行代码。
  * 若不被抢占，则一直执行代码，因为I/O阻塞很少。
  * 这种进程一般需要降低调度频率，延长运行时间。
* 划分并不绝对。

调度策略需要平衡**进程响应速度**和**系统利用率**。
* Linux保证了交互系统的性能，优化了进程的响应速度，更倾向于优先调度I/O消耗型进程。

### 进程优先级

调度程序总是选择时间片未用尽且优先级最高的进程运行。

Linux使用了两种不同的优先级范围。
* 第一种是nice值，范围是\[-20,20)。
  * 默认值为0，**值越大优先级越低**。
  * Linux中nice值代表时间片的比例（通过ps -el查看NI字段）。
* 第二种是实时优先级，变化范围是\[0,100)。
  * 实时优先级数值越高，进程优先级就越高。
  * 任何实时进程的优先级都比普通进程高->实时优先级和nice值不会冲突。
  * 实现方式参考了POSIX.1b，
  * `ps -eo pid,rtprio,comm`查看rtprio字段，若为`-`则说明不是实时进程。

### 时间片

时间片表明进程在被抢占前所能持续运行的时间。
* 时间片分配的长短很难把控。
* I/O消耗型不需要长的时间片，而处理器消耗型则希望越长越好。

> 时间片默认很短，达到毫秒级。

Linux的CFS调度器并不是直接分配时间片到进程，而是**将处理器的比例划分给了进程**。
* 这样进程获得的**处理器时间就和系统负载**直接挂钩了。
* 这个划分比例会**受到nice值的影响**。
* 抢占时机取决于新的可运行程序消耗了多少处理器使用比。
  * 消耗处理器使用比例更小的投入运行。

### 调度策略的活动

假设有两个进程：文本编辑程序（I/O消耗型）和视频编码程序（处理器消耗型）。
* 理想情况应该是给文本编辑程序更多的处理器时间。
  * 希望它在需要时总能获得处理器，而不是因为它需要更多的处理器时间。
  * 希望文本编辑程序在被唤醒时能够抢占视频编码程序。
* Linux通过分配给定的使用比来实现。
  * 假设nice值相同，它们都分到的处理器使用比都是50%。
  * 视频编码程序总是能在文本处理程序阻塞时获得处理器，总共能使用到大于50%的处理器。
  * 由于文本处理器真正执行时间短，所以使用比更小，使得它总是能抢占视频编码程序。（**公平分享原则**）

## Linux调度算法

### 调度器类

Linux调度器是以**模块**方式提供的，允许了*不同类型*的进程可以有针对性的**选择调度算法**。
* 模块化的结构被称为**调度器类**，其允许*多种不同的可动态添加的调度算法*并存。

> CFS算法定义在kernel/sched_fair.c中。

### Unix系统中的进程调度

在Unix系统上，优先级以nice值的形式输出给用户空间。这会导致很多反常的问题。
* 若要将nice值映射到时间片，就必须存在nice单位值向单位时间片的转化。
  * 这样必然无法合理分配时间片。
* 相对nice值的问题。
  * 例：相比于nice值0和1的区别，18和19的区别更明显。
  * nice值变化的影响仅取决于nice的初始值。
* 如果需要完成映射，就需要分配一个绝对时间片。
  * 该时间片必须在内核的测试范围内，且必须是定时器节拍的整数倍。
  * 参看第11章了解定时器节拍。
* 基于优先级的调度器**为了优化交互任务而唤醒相关进程**的问题。
  * 为了进程能尽快投入运行，就对新的需要唤醒的进程提升优先级（就算它的时间片可能已经用完了）。
  * 对于一些经常睡眠+唤醒的进程更有利，导致其获得很多处理器时间。

CFS重新设计了时间片分配方式。
* **完全摒弃时间片**，而是给进程一个处理器使用比重。
* 确保了进程调度中有恒定的公平性，而**让切换频率不断变动**。

### 公平调度

> 调度周期越小，交互性越好。

CFS的理想情况：每个进程（总共n个可运行进程）都可以分配到1/n的处理器时间。
* 同时给进程很短的时间周期。但这样会导致经常调度。
* 所以CFS不采用时间片，而是按照nice值分配使用比例，然后在所有可运行进程总数基础上计算出一个进程应该运行多久。

CFS为*无限小调度周期*设立了一个目标，称作**目标延迟**。
* 目标延迟可以理解为某个进程距离上一次运行之间的时间间隔最大值。
* 为防止可运行进程增加时，使用比无限小的情况发生。CFS设置了时间片的最小粒度，默认情况为1ms。

只有**相对值**才会影响处理器时间的分配比例。
* nice值对时间片的作用是**几何加权**，而不是算数加权。

## Linux调度的实现

相关代码位于kernel/sched_fair.c中。

### 时间记账

时间记账就是对进程的运行时间进行记录。保证进程的时间片减到0时，可以被抢占。

1. 调度器实体结构
* 定义在linux/sched.h的[sched_entity](https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L537)中，在task_struct中作为se成员变量。
* CFS用该结构来进行**记账**。

2. 虚拟实时
* sched_entity的vruntime用于存放虚拟运行时间，这是根据所有可运行进程总数标准化后的值。
* 由于*处理器并不理想*，所以需要vruntime记录进程到底运行了多长时间。
* [update_curr()](https://elixir.bootlin.com/linux/latest/source/kernel/sched/fair.c#L885)记录了该记账功能。

### 进程选择

CFS选择**vruntime值最小**的任务进行调度。

CFS使用**红黑树**来组织可运行进程队列。
* 有了红黑树，我们就可以通过键值来快速检索节点上的数据（这是因为索引的速度和树的节点规模成**指数比**关系）。

1. 挑选下一个任务
* 选择红黑树的最左（目前版本是最右）的节点，实现函数是[__pick_next_entity()](https://elixir.bootlin.com/linux/latest/source/kernel/sched/fair.c#L647)。
  * 如果left为null，CFS调度idle进程。

2. 向树中加入进程
* 实现函数是[enqueue_entity()](https://elixir.bootlin.com/linux/latest/source/kernel/sched/fair.c#L4411)，该函数先更新运行时间再进行插入。

3. 从树中删除进程
* 实现函数是[dequeue_entity()](https://elixir.bootlin.com/linux/latest/source/kernel/sched/fair.c#L4512)。

