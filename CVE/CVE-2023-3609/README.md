# 介绍

|属性|值|
|-|-|
|编号|CVE-2023-3609|
|版本|4.14-rc1到v6.4-rc7|
|目的|UAF|
|参考|[kernelctf](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3609_cos_mitigation/docs/exploit.md)、[hackedbylh](https://xz.aliyun.com/t/13295?time__1311=GqmxuD0DnDyAKGNeeequADgiD97AYeDcmaoD#toc-0)|

# 概述

这个漏洞存在于Linux内核的`net/sched: cls_u32`组件中，具体是在`u32_set_parms()`函数内。问题出现在` tcf_change_indev()`调用失败时，`u32_set_parms()`会立即返回错误，但在返回之前已经修改了引用计数。由于没有正确管理引用计数，特别是在失败的情况下，可能会导致引用计数器的不一致。如果攻击者能够控制引用计数，并将其设置为零，就会触发引用释放，从而导致**use-after-free**漏洞。利用这一漏洞，攻击者可以触发内存访问错误，进而实现本地权限提升攻击。

# 背景

## Linux内核网络子系统（Networking Subsystem）
- **网络调度器（Netfilter / Traffic Control）**：Linux内核的流量控制功能，包括流量分类、队列调度、数据包过滤等。
  - `cls_u32`是一个分类器，用于基于32位整数（例如IP地址）对网络流量进行分类。
   - **tcf_proto**：表示与Traffic Control过滤器相关的数据结构，通常用于流量分类和过滤的设置。
   - **Netlink协议**：用于用户空间与内核之间的通信，特别是在配置网络接口、路由、流量控制等时，Netlink提供了一个通用的机制。

* 内核网络栈中的`nlattr`和`extack`
   - **nlattr**：Netlink属性，用于传递网络配置的数据结构，通常在网络配置或流量控制中传递信息。
   - **netlink_ext_ack**：是一个结构体，用于在Netlink通信中传递详细的错误信息，有助于调试和错误处理。

* 内核流量控制机制（Traffic Control）
   - Linux内核提供了丰富的流量控制功能，用于管理和优化网络数据包的调度。分类器（如`cls_u32`）是流量控制的一部分，负责将流量根据不同的条件（例如IP地址、端口）分配到不同的队列中。

* `ifindex`的意义
   - `ifindex`表示网络接口的索引，它在内核中用于标识一个具体的网络设备。该补丁中的`ifindex`变量用于存储修改网络设备后的接口索引，以便后续在结构体中更新正确的接口索引。

## 引用计数

在Linux内核中，**引用计数**（Reference Counting）是管理动态分配内存或对象生命周期的重要机制。它的基本思想是通过一个计数器来跟踪某个资源（例如对象、内存块等）被多少个引用所使用，当计数器为零时，表示该资源不再被任何地方使用，可以安全地释放。

在Linux内核中，引用计数广泛用于管理各种资源，例如网络套接字、文件描述符、内存页、设备等。对于每个对象，都有一个计数器（通常是`refcount_t`类型），表示当前有多少个地方引用了该对象。当对象被引用时，引用计数会递增；当引用不再使用时，计数器递减。当引用计数降到零时，内核可以安全地释放该资源。

# 原理

漏洞的原理是由于在 `u32_set_parms` 函数中，当 `tcf_change_indev` 返回错误时，导致引用计数 `ht_down->refcnt` 泄漏，进而可能引发引用计数溢出问题，最终造成 UAF（Use-After-Free）漏洞。

`u32_set_parms` 函数的核心功能是设置一些与 U32 过滤器相关的参数。在函数中，当处理 `TCA_U32_LINK` 时，会查找并增加 `ht_down->refcnt`，这是一个引用计数的管理。具体代码如下：

```c
if (tb[TCA_U32_LINK]) {
    u32 handle = nla_get_u32(tb[TCA_U32_LINK]);
    struct tc_u_hnode *ht_down = NULL, *ht_old;

    if (handle) {
        ht_down = u32_lookup_ht(tp->data, handle);
        ht_down->refcnt++;  // [1] 增加 ht_down->refcnt
    }

    ht_old = rtnl_dereference(n->ht_down);
    rcu_assign_pointer(n->ht_down, ht_down);

    if (ht_old)
        ht_old->refcnt--;
}
```

- 当 `TCA_U32_LINK` 被设置时，`u32_lookup_ht` 查找对应的 `tc_u_hnode`，并将其引用计数 `ht_down->refcnt` 增加。
- 旧的 `ht_down` 被保存，并且引用计数减少。

接下来是对 `TCA_U32_CLASSID` 和 `TCA_U32_INDEV` 的处理。如果 `TCA_U32_INDEV` 被提供，会调用 `tcf_change_indev` 来更新网络设备索引：

```c
if (tb[TCA_U32_INDEV]) {
    int ret;
    ret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
    if (ret < 0)
        return -EINVAL;  // 如果 tcf_change_indev 返回错误，提前退出
    n->ifindex = ret;
}
```

当 `tcf_change_indev` 返回错误时，`u32_set_parms` 会直接返回 `-EINVAL` 并退出，但并未处理已经增加的引用计数。这样，如果在该函数的调用过程中，`ht_down->refcnt` 被增加了，但未正确释放，就会导致引用计数泄漏。

# 利用

## 构造

我们通过以下步骤构建漏洞利用过程：

1. **分配 `drr_class` (C1)**

首先，我们需要分配一个 `drr_class` 对象（假设为 C1）。此时，`C1->filter_cnt` 被初始化为 0，表示该类对象还没有被绑定到任何过滤器。

```c
struct drr_class *C1 = alloc_drr_class();
C1->filter_cnt = 0;
```

2. **通过 `u32_change` 新建 `tc_u_knode` (N1) 并绑定 `C1`**

接下来，通过 `u32_change` 函数的代码 [2] 分支，新建一个 `tc_u_knode` 对象（假设为 N1）。`N1` 会引用 `C1`，即将 `C1` 的 `filter_cnt` 增加到 1。

```c
struct tc_u_knode *N1 = alloc_tc_u_knode();
N1->res.class = C1;
C1->filter_cnt = 1;  // C1 已被引用
tp->root->ht[0] = N1; // N1 被添加到哈希表中
```

此时，`N1` 和 `C1` 建立了关联，且 `C1->filter_cnt` 已增至 1。

3. **进入 `u32_set_parms`，触发 `unbind_tcf`**

在 `u32_change` 函数的代码 [1] 分支执行时，`n = N1`，并且会将 `N1->res` 分配给新的 `tc_u_knode` 对象。此时，进入 `u32_set_parms` 函数后，调用 `tcf_bind_filter`，会触发 `unbind_tcf` 操作。

由于 `n->res.class` 已经指向 `C1`，`unbind_tcf` 会将 `C1->filter_cnt` 设为 0，解除该类的绑定。

```c
tcf_bind_filter(tp, &n->res, base);
unbind_tcf(C1);
C1->filter_cnt = 0;  // 错误地减少引用计数
```

此时，`C1->filter_cnt` 被错误地减少至 0，导致 `C1` 被标记为可以释放。

4. **错误的 `tcf_change_indev` 触发函数失败**

由于传入 `tcf_change_indev` 的参数是错误的，它返回了错误码，导致 `u32_set_parms` 返回失败。

```c
ret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
if (ret < 0) return -EINVAL;
```

此时，`u32_change` 由于 `u32_set_parms` 的失败，返回了错误。`N1` 和 `C1` 未得到正确清理，从而发生引用计数泄漏。

5. **释放 `C1`，`filter_cnt` 已为 0**

因为 `C1->filter_cnt` 被错误地减少到 0，`C1` 被标记为可以释放。通过调用 `tc_ctl_tclass`，`C1` 被正常释放。

```c
tc_ctl_tclass(C1);
```

此时，`C1` 被销毁，因为它的 `filter_cnt` 为 0。

6. **触发 Use-After-Free**

随着后续的包处理，通过 `drr_enqueue` 函数，`tcf_classify` 和 `u32_classify` 会在 `tp->root->ht[0]` 中找到 `N1`，并使用 `N1->res.class` 访问 `C1`。

然而，由于 `C1` 已经在前面被释放，再次访问 `C1` 会导致 **Use-After-Free (UAF)** 漏洞。

```c
tcf_classify(tp, skb);   // 使用已经释放的 C1
```

这时，`C1` 已经不再有效，造成了对已释放内存的访问。

## 提权

以下是漏洞触发和利用的关键代码片段：

### 关键函数指针：`enqueue`

```c
static int drr_enqueue(struct sk_buff *skb, struct Qdisc *sch,
		       struct sk_buff **to_free)
{
	unsigned int len = qdisc_pkt_len(skb);
	struct drr_sched *q = qdisc_priv(sch);
	struct drr_class *cl;
	int err = 0;
	bool first;

	cl = drr_classify(skb, sch, &err); // [1]
	...
	err = qdisc_enqueue(skb, cl->qdisc, to_free); // [2]
	...
	return err;
}
```

- 在 `drr_enqueue` 函数中，`drr_classify` 被调用来获得 `drr_class` 对象（`cl`）。此时，由于 `drr_class` 对象已经被释放，`cl->qdisc` 指针指向一个已释放的 `qdisc` 对象。
- 然后，`qdisc_enqueue` 函数被调用，其中 `cl->qdisc` 被传递到 `qdisc_enqueue` 函数。

```c
static inline int qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,
				struct sk_buff **to_free)
{
	qdisc_calculate_pkt_len(skb, sch);
	return sch->enqueue(skb, sch, to_free); // [2]
}
```

- 在 `qdisc_enqueue` 中，调用了 `sch->enqueue` 函数指针。如果攻击者能够控制 `sch->enqueue`，则可以在此处覆盖该函数指针，进而执行恶意代码。

### 利用目标：`drr_class` 对象

我们的目标对象是 `struct drr_class`，它分配在 `kmalloc-128` 缓存中。攻击者可以通过一些技术来使 `drr_class` 对象被重新分配并释放，从而为函数指针覆盖创造条件。

堆喷目标对象：
1. **LTS/COS 实例：**由于没有启用 `CONFIG_KMALLOC_SPLIT_VARSIZE`，攻击者可以通过重新分配 `struct drr_class` 对象（使用 `ctl_buf`）来进行对象喷洒。通过 `sendmsg` 系统调用，攻击者可以将 `ctl_buf` 塞入具有可控数据的消息中，诱使内核重新分配目标对象。

   ```c
   static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,
			      unsigned int flags, struct used_address *used_address,
			      unsigned int allowed_msghdr_flags)
   ...
   if (ctl_len > sizeof(ctl)) {
       ctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);
       if (ctl_buf == NULL)
           goto out;
   }
   err = -EFAULT;
   if (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len)) //[3]
       goto out_freectl;
   ```

2. **Mitigation 实例：**如果启用了 `CONFIG_KMALLOC_SPLIT_VARSIZE`，攻击者需要找到合适的结构体来喷洒。`ctnetlink_filter` 结构体就在适合的缓存中。攻击者可以通过喷洒这个结构体并插入有效负载来控制 `drr_class` 对象的重新分配。

   ```c
   static struct ctnetlink_filter *ctnetlink_alloc_filter(const struct nlattr * const cda[], u8 family)
   {
       struct ctnetlink_filter *filter;
       int err;
       ...
       filter = kzalloc(sizeof(*filter), GFP_KERNEL);
       ...
   }
   ```