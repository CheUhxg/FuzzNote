# 介绍

|属性|值|
|-|-|
|编号|CVE-2023-3609|
|版本|4.14-rc1到v6.4-rc7|
|目的|UAF|

# 概述

这个漏洞存在于Linux内核的`net/sched: cls_u32`组件中，具体是在`u32_set_parms()`函数内。问题出现在` tcf_change_indev()`调用失败时，`u32_set_parms()`会立即返回错误，但在返回之前已经修改了引用计数。由于没有正确管理引用计数，特别是在失败的情况下，可能会导致引用计数器的不一致。如果攻击者能够控制引用计数，并将其设置为零，就会触发引用释放，从而导致**use-after-free**漏洞。利用这一漏洞，攻击者可以触发内存访问错误，进而实现本地权限提升攻击。

# 背景

## Linux内核网络子系统（Networking Subsystem）
- **网络调度器（Netfilter / Traffic Control）**：Linux内核的流量控制功能，包括流量分类、队列调度、数据包过滤等。
  - `cls_u32`是一个分类器，用于基于32位整数（例如IP地址）对网络流量进行分类。
   - **tcf_proto**：表示与Traffic Control过滤器相关的数据结构，通常用于流量分类和过滤的设置。
   - **Netlink协议**：用于用户空间与内核之间的通信，特别是在配置网络接口、路由、流量控制等时，Netlink提供了一个通用的机制。

* 内核网络栈中的`nlattr`和`extack`
   - **nlattr**：Netlink属性，用于传递网络配置的数据结构，通常在网络配置或流量控制中传递信息。
   - **netlink_ext_ack**：是一个结构体，用于在Netlink通信中传递详细的错误信息，有助于调试和错误处理。

* 内核流量控制机制（Traffic Control）
   - Linux内核提供了丰富的流量控制功能，用于管理和优化网络数据包的调度。分类器（如`cls_u32`）是流量控制的一部分，负责将流量根据不同的条件（例如IP地址、端口）分配到不同的队列中。

* `ifindex`的意义
   - `ifindex`表示网络接口的索引，它在内核中用于标识一个具体的网络设备。该补丁中的`ifindex`变量用于存储修改网络设备后的接口索引，以便后续在结构体中更新正确的接口索引。

## 引用计数

在Linux内核中，**引用计数**（Reference Counting）是管理动态分配内存或对象生命周期的重要机制。它的基本思想是通过一个计数器来跟踪某个资源（例如对象、内存块等）被多少个引用所使用，当计数器为零时，表示该资源不再被任何地方使用，可以安全地释放。

在Linux内核中，引用计数广泛用于管理各种资源，例如网络套接字、文件描述符、内存页、设备等。对于每个对象，都有一个计数器（通常是`refcount_t`类型），表示当前有多少个地方引用了该对象。当对象被引用时，引用计数会递增；当引用不再使用时，计数器递减。当引用计数降到零时，内核可以安全地释放该资源。

### `u32_set_parms()`中的引用计数问题
在给定的补丁中，`u32_set_parms()`函数涉及了`ifindex`（接口索引）的修改，涉及到对网络接口引用计数的管理。问题的关键在于，当调用` tcf_change_indev()`（用于更改网络接口）时，如果操作失败，原本递增的引用计数没有被正确递减。这会导致计数器增大，直到溢出，从而释放一个已经无效的对象，这就会引发双重释放（double free）等严重问题。

### 原有代码中的引用计数问题
原始的`u32_set_parms()`函数在调用` tcf_change_indev()`时，直接将返回值赋给`n->ifindex`，但如果` tcf_change_indev()`失败，函数会直接返回，导致之前对引用计数的递增没有相应的递减处理。因此，引用计数在某些情况下会持续增加，直到溢出，并最终释放无效内存。

### 修复方案的引用计数管理
在修复后的代码中，通过引入一个局部变量`ifindex`来保存` tcf_change_indev()`的返回值。修改的关键点在于：

- **引用计数递增的位置**：原代码在调用` tcf_change_indev()`后，直接递增了引用计数，而没有判断是否成功。修复后的代码将` tcf_change_indev()`的调用放在引用计数递增之前，并且只有当成功时才将`ifindex`更新为接口索引。
- **确保成功后才递增**：通过将失败处理逻辑（返回错误）移到引用计数递增之前，确保只有在操作成功时才会影响引用计数。这有效地避免了由于失败导致的引用计数泄漏。

### 具体修改分析
1. **原始代码**：

   ```c
   if (tb[TCA_U32_INDEV]) {
       int ret;
       ret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
       if (ret < 0)
           return -EINVAL;
       n->ifindex = ret;
   }
   ```

   这里的` tcf_change_indev()`调用如果失败（`ret < 0`），会直接返回错误，但在此之前已经进行了引用计数的增加（即引用计数被错误地递增了），导致无法撤销操作。

2. **修复后的代码**：

   ```c
   if (tb[TCA_U32_INDEV]) {
       ifindex = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
       if (ifindex < 0)
           return -EINVAL;
   }
   if (ifindex >= 0)
       n->ifindex = ifindex;
   ```

   修复后的代码中，` tcf_change_indev()`的调用结果首先保存在局部变量`ifindex`中。只有当成功时（即`ifindex >= 0`），才将其赋值给`n->ifindex`，从而确保引用计数在操作失败时不会被错误地递增。

### 结论
引用计数是内核中管理资源生命周期的关键机制，必须谨慎处理。尤其是在涉及多次调用、错误处理和资源释放时，需要确保每一次引用计数的增加和减少都严格匹配。在此补丁中，修复了`u32_set_parms()`函数中的引用计数管理问题，避免了由于` tcf_change_indev()`失败时引用计数递增未递减导致的双重释放问题，从而提升了内核的内存安全性。

# 原理

# 利用