# 介绍

|属性|值|
|-|-|
|编号|CVE-2023-3609|
|版本|4.14-rc1到v6.4-rc7|
|目的|UAF|

# 概述

这个漏洞存在于Linux内核的`net/sched: cls_u32`组件中，具体是在`u32_set_parms()`函数内。问题出现在` tcf_change_indev()`调用失败时，`u32_set_parms()`会立即返回错误，但在返回之前已经修改了引用计数。由于没有正确管理引用计数，特别是在失败的情况下，可能会导致引用计数器的不一致。如果攻击者能够控制引用计数，并将其设置为零，就会触发引用释放，从而导致**use-after-free**漏洞。利用这一漏洞，攻击者可以触发内存访问错误，进而实现本地权限提升攻击。

# 背景

## Linux内核网络子系统（Networking Subsystem）
- **网络调度器（Netfilter / Traffic Control）**：Linux内核的流量控制功能，包括流量分类、队列调度、数据包过滤等。
  - `cls_u32`是一个分类器，用于基于32位整数（例如IP地址）对网络流量进行分类。
   - **tcf_proto**：表示与Traffic Control过滤器相关的数据结构，通常用于流量分类和过滤的设置。
   - **Netlink协议**：用于用户空间与内核之间的通信，特别是在配置网络接口、路由、流量控制等时，Netlink提供了一个通用的机制。

* 内核网络栈中的`nlattr`和`extack`
   - **nlattr**：Netlink属性，用于传递网络配置的数据结构，通常在网络配置或流量控制中传递信息。
   - **netlink_ext_ack**：是一个结构体，用于在Netlink通信中传递详细的错误信息，有助于调试和错误处理。

* 内核流量控制机制（Traffic Control）
   - Linux内核提供了丰富的流量控制功能，用于管理和优化网络数据包的调度。分类器（如`cls_u32`）是流量控制的一部分，负责将流量根据不同的条件（例如IP地址、端口）分配到不同的队列中。

* `ifindex`的意义
   - `ifindex`表示网络接口的索引，它在内核中用于标识一个具体的网络设备。该补丁中的`ifindex`变量用于存储修改网络设备后的接口索引，以便后续在结构体中更新正确的接口索引。

## 引用计数

在Linux内核中，**引用计数**（Reference Counting）是管理动态分配内存或对象生命周期的重要机制。它的基本思想是通过一个计数器来跟踪某个资源（例如对象、内存块等）被多少个引用所使用，当计数器为零时，表示该资源不再被任何地方使用，可以安全地释放。

在Linux内核中，引用计数广泛用于管理各种资源，例如网络套接字、文件描述符、内存页、设备等。对于每个对象，都有一个计数器（通常是`refcount_t`类型），表示当前有多少个地方引用了该对象。当对象被引用时，引用计数会递增；当引用不再使用时，计数器递减。当引用计数降到零时，内核可以安全地释放该资源。

# 原理

漏洞的原理是由于在 `u32_set_parms` 函数中，当 `tcf_change_indev` 返回错误时，导致引用计数 `ht_down->refcnt` 泄漏，进而可能引发引用计数溢出问题，最终造成 UAF（Use-After-Free）漏洞。

`u32_set_parms` 函数的核心功能是设置一些与 U32 过滤器相关的参数。在函数中，当处理 `TCA_U32_LINK` 时，会查找并增加 `ht_down->refcnt`，这是一个引用计数的管理。具体代码如下：

```c
if (tb[TCA_U32_LINK]) {
    u32 handle = nla_get_u32(tb[TCA_U32_LINK]);
    struct tc_u_hnode *ht_down = NULL, *ht_old;

    if (handle) {
        ht_down = u32_lookup_ht(tp->data, handle);
        ht_down->refcnt++;  // [1] 增加 ht_down->refcnt
    }

    ht_old = rtnl_dereference(n->ht_down);
    rcu_assign_pointer(n->ht_down, ht_down);

    if (ht_old)
        ht_old->refcnt--;
}
```

- 当 `TCA_U32_LINK` 被设置时，`u32_lookup_ht` 查找对应的 `tc_u_hnode`，并将其引用计数 `ht_down->refcnt` 增加。
- 旧的 `ht_down` 被保存，并且引用计数减少。

接下来是对 `TCA_U32_CLASSID` 和 `TCA_U32_INDEV` 的处理。如果 `TCA_U32_INDEV` 被提供，会调用 `tcf_change_indev` 来更新网络设备索引：

```c
if (tb[TCA_U32_INDEV]) {
    int ret;
    ret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
    if (ret < 0)
        return -EINVAL;  // 如果 tcf_change_indev 返回错误，提前退出
    n->ifindex = ret;
}
```

当 `tcf_change_indev` 返回错误时，`u32_set_parms` 会直接返回 `-EINVAL` 并退出，但并未处理已经增加的引用计数。这样，如果在该函数的调用过程中，`ht_down->refcnt` 被增加了，但未正确释放，就会导致引用计数泄漏。

# 利用