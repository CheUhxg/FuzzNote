# 介绍

|属性|值|
|-|-|
|编号|CVE-2022-0995|
|版本|(-∞, 5.17-rc7]|
|目的|OOB|
|参考|[Bonfee](https://github.com/Bonfee/CVE-2022-0995)|

# 概述

ioctl的IOC_WATCH_QUEUE_SET_FILTER操作中，对于watch_filter的判断条件不一致，导致OOB写。

# 原理

## 漏洞点

```c
long watch_queue_set_filter(struct pipe_inode_info *pipe,
			    struct watch_notification_filter __user *_filter)
{
	struct watch_notification_type_filter *tf;
	struct watch_notification_filter filter;
	struct watch_type_filter *q;
	struct watch_filter *wfilter;
	struct watch_queue *wqueue = pipe->watch_queue;
	int ret, nr_filter = 0, i;

	if (!wqueue)
		return -ENODEV;

	if (!_filter) {
		/* Remove the old filter */
		wfilter = NULL;
		goto set;
	}

	/* Grab the user's filter specification */
	if (copy_from_user(&filter, _filter, sizeof(filter)) != 0)
		return -EFAULT;
	if (filter.nr_filters == 0 ||
	    filter.nr_filters > 16 ||
	    filter.__reserved != 0)
		return -EINVAL;

	tf = memdup_user(_filter->filters, filter.nr_filters * sizeof(*tf));
	if (IS_ERR(tf))
		return PTR_ERR(tf);

	ret = -EINVAL;
	for (i = 0; i < filter.nr_filters; i++) {
		if ((tf[i].info_filter & ~tf[i].info_mask) ||
		    tf[i].info_mask & WATCH_INFO_LENGTH)
			goto err_filter;
		/* Ignore any unknown types */
		if (tf[i].type >= sizeof(wfilter->type_filter) * 8)
			continue;
		nr_filter++;
	}

	/* Now we need to build the internal filter from only the relevant
	 * user-specified filters.
	 */
	ret = -ENOMEM;
	wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);
	if (!wfilter)
		goto err_filter;
	wfilter->nr_filters = nr_filter;

	q = wfilter->filters;
	for (i = 0; i < filter.nr_filters; i++) {
		if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG)
			continue;

		q->type			= tf[i].type;
		q->info_filter		= tf[i].info_filter;
		q->info_mask		= tf[i].info_mask;
		q->subtype_filter[0]	= tf[i].subtype_filter[0];
		__set_bit(q->type, wfilter->type_filter);
		q++;
	}

	kfree(tf);
set:
	pipe_lock(pipe);
	wfilter = rcu_replace_pointer(wqueue->filter, wfilter,
				      lockdep_is_held(&pipe->mutex));
	pipe_unlock(pipe);
	if (wfilter)
		kfree_rcu(wfilter, rcu);
	return 0;

err_filter:
	kfree(tf);
	return ret;
}
```

从上述代码中可以看到，变量wfilter的成员filters（可变长数组）分配的大小取决于变量nr_filter，而nr_filter的递增条件为`tf[i].type < sizeof(wfilter->type_filter) * 8`。后来对wfilter->filters写的时候，判断条件变为了`tf[i].type < sizeof(wfilter->type_filter) * BITS_PER_LONG`，其中BITS_PER_LONG为64。如果控制`tf[i].type`在两者之间，则可以实现申请内存少于实际写入的内存，实现OOB写。

# 利用

该漏洞利用主要依赖于__set_bit宏，在这里使用__set_bit(q->type, wfilter->type_filter)，实际上是将变量wfilter->type_filter偏移大小为q->type的位置设置为1。结合上述OOB能力，相当于能够在指定范围内指定比特为1。

指定比特的利用参考[CVE-2021-22555](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html)。
