# 介绍

|属性|值|
|-|-|
|编号|CVE-2017-11176|
|版本|\[2.6.27, 4.11.10\]|
|目的|UAF|
|参考|[lexfo](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html)|

# 概述

内核中的mq_notify函数在进入retry时不会将sock指针设置为NULL。在用户空间关闭Netlink套接字，它允许攻击者导致拒绝服务(UAF)或可能具有未知其他影响(提权)。

# 背景

## 进程和文件的关联

* [进程描述符](https://github.com/CheUhxg/FuzzNote/blob/main/Background/comm.md#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6)
* [文件描述符](https://github.com/CheUhxg/FuzzNote/blob/main/Background/comm.md#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)
* [进程和文件的关联](https://github.com/CheUhxg/FuzzNote/blob/main/Background/comm.md#%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E8%81%94)

## Socket, Sock and SKB

* [虚函数表](https://github.com/CheUhxg/FuzzNote/blob/main/Background/comm.md#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8)
* [Socket, Sock 和 SKB](https://github.com/CheUhxg/FuzzNote/blob/main/Background/comm.md#socket-sock-%E5%92%8C-skb)
* [Netlink Socket](https://github.com/CheUhxg/FuzzNote/blob/main/Background/comm.md#netlink-socket)

![整合](https://blog.lexfo.fr/images/cve-2017-11176-linux/core_struct_relationship.png)

# 原理

## 漏洞点

系统调用mq_notify()核心代码如下。

```c
// from [ipc/mqueue.c]

    SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,
          const struct sigevent __user *, u_notification)
      {
        int ret;
        struct file *filp;
        struct sock *sock;
        struct sigevent notification;
        struct sk_buff *nc;

        // ... cut (copy userland data to kernel + skb allocation) ...

        sock = NULL;
    retry:
[0]       filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
[1]         goto out;
          }
[2a]      sock = netlink_getsockbyfilp(filp);   // sock refcounter++
[2b]      fput(filp);
          if (IS_ERR(sock)) {
            ret = PTR_ERR(sock);
            sock = NULL;
[3]         goto out;
          }

          timeo = MAX_SCHEDULE_TIMEOUT;
[4]       ret = netlink_attachskb(sock, nc, &timeo, NULL);  // if err, sock refcounter--
          if (ret == 1)
[5a]        goto retry;
          if (ret) {
            sock = NULL;
            nc = NULL;
[5b]        goto out;
          }

[5c]    // ... cut (normal path) ...

      out:
        if (sock) {
          netlink_detachskb(sock, nc);  // sock refcounter--
        } else if (nc) {
          dev_kfree_skb(nc);
        }
        return ret;
      }
```

* \[0\]：根据信号中的文件描述符寻找并引用对应的文件对象。
* \[1\]：若文件描述符表中没有该文件描述符，则退出。
* \[2a\]：根据得到的文件对象，获取sock。
* \[2b\]：释放得到的文件对象。
* \[3\]：若sock类型出错，将sock置NULL并退出。
* \[4\]：执行netlink_attachskb()，将struct sk_buff(nc)加入struct sock接收队列。根据返回值进入不同执行流程。
* \[5a\]：\[4\]返回值为1，进入retry。
* \[5b\]：\[4\]返回值为非0、1，将nc和sock置NULL并退出。
* \[5c\]：\[4\]返回值为0，继续执行。

根据代码中标注的sock引用/释放位置，可以判断出：经过\[2a\]->\[4\]->\[1\]，到达out执行netlink_detachskb()后，sock会被额外多减少一次引用计数。
* 此时需要保证在第一次进入retry时，fget正常返回，而第二次进入retry时，fget返回NULL。这就涉及一个**竞态条件**。

Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
|------------------------------------|-----------------------|-------------|-------------|--------------------|
| mq_notify()                        |                       | 1           | 1           | NULL               |
|  fget(<TARGET_FD>) -> ok           |                       | 2 (+1)      | 1           | NULL               |
|  netlink_getsockbyfilp() -> ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
|  fput(<TARGET_FD>) -> ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
|  netlink_attachskb() -> returns 1  |                       | 1           | 1 (-1)      | 0xffffffc0aabbccdd |
|                                    | close(<TARGET_FD>)    | 0 (-1)      | 0 (-1)      | 0xffffffc0aabbccdd |
|goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
|  fget(<TARGET_FD) -> returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
|  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
|  netlink_detachskb() -> UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |

# 利用

