# 介绍

|属性|值|
|-|-|
|编号|CVE-2022-27666|
|版本|v5.17-rc8|
|目的|OOB|

# 概述

ESP6协议申请接收缓冲区的大小默认为8页，但是发送的数据可以大于8页，所以可以造成OOB写。

# 原理

ESP6调用esp6_output_head()来分配接收缓冲区大小。
* 底层调用skb_page_frag_refill()，在该函数中，**始终分配8页大小的内存**，与实际申请内存大小无关。

```c
bool skb_page_frag_refill(unsigned int sz, struct page_frag *pfrag, gfp_t gfp)
{
        if (pfrag->offset + sz <= pfrag->size)
		return true;
	...
	if (SKB_FRAG_PAGE_ORDER &&
	    !static_branch_unlikely(&net_high_order_alloc_disable_key)) {

		pfrag->page = alloc_pages((gfp & ~__GFP_DIRECT_RECLAIM) |
					  __GFP_COMP | __GFP_NOWARN |
					  __GFP_NORETRY,
					  SKB_FRAG_PAGE_ORDER);
		...
	}
	...
	return false;
}
```

如果发送的数据大小大于8页，则在null_skcipher_crypt()函数发生OOB。
* 调用memcpy()时传入发送数据的长度，该值大于接收缓冲区的大小。

```c
static int null_skcipher_crypt(struct skcipher_request *req)
{
	struct skcipher_walk walk;
	int err;

	err = skcipher_walk_virt(&walk, req, false);

	while (walk.nbytes) {
		if (walk.src.virt.addr != walk.dst.virt.addr)
			// out-of-bounds write
			memcpy(walk.dst.virt.addr, walk.src.virt.addr,
			       walk.nbytes);
		err = skcipher_walk_done(&walk, 0);
	}

	return err;
}
```
