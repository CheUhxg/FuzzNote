# 背景

[参考](https://anatomic.rip/cve-2023-2598/)

## io_uring

[参考](https://chomp.ie/Blog+Posts/Put+an+io_uring+on+it+-+Exploiting+the+Linux+Kernel#io_uring+What+is+it%3F)

简而言之，io_uring 是一个用于 Linux 的 API，允许应用程序异步执行系统调用，并且在性能上比普通系统调用有显著提升。通过 io_uring，程序可以避免等待阻塞的系统调用，并且由于其实现方式，还减少了实际需要执行的系统调用次数。

### 提交队列和完成队列

io_uring 的核心组件是两个环形缓冲区：提交队列（Submission Queue, SQ）和完成队列（Completion Queue, CQ）。这两个环形缓冲区在应用程序和内核之间共享。

在提交队列中，包含了提交队列项（Submission Queue Entries, SQEs），每个项描述了**需要执行的系统调用**。应用程序随后通过执行 `io_uring_enter` 系统调用来通知内核：提交队列中有等待处理的任务。

甚至可以配置**提交队列轮询**，以不必使用 `io_uring_enter`，从而将所需的实际系统调用数**减少为零**。

当内核执行完操作后，会将完成队列项（Completion Queue Entry, CQE）放入完成队列的环形缓冲区中，供应用程序消费。

### 固定缓冲区

**可以注册固定缓冲区**以用于读写数据的操作。这些**缓冲区所占的页会被固定和映射**，从而避免在用户空间和内核空间之间反复复制数据。

固定缓冲区的注册通过 `io_uring_register` 系统调用中的 `IORING_REGISTER_BUFFERS` 操作完成，并可以使用 `IOSQE_BUFFER_SELECT` SQE 标志来选择所需的缓冲区。

由于固定缓冲区在 io_uring 中非常关键，后续将进一步探讨它们的使用。

### liburing

幸运的是，liburing 库为设置 io_uring 实例和与子系统交互提供了便利。它简化了缓冲区设置、生成 SQEs 和收集 CQEs 等操作。

liburing 的维护者 Jens Axboe 同时也是 io_uring 的维护者，因此该库可以保持与内核端的更新同步，使开发者（包括漏洞利用开发者）能更方便地使用 io_uring。

# 漏洞

[6.3-rc1, 6.4-rc1]

## 漏洞成因

漏洞的根本原因是**注册缓冲区时的优化错误**。

通过传递 IORING_REGISTER_BUFFERS 操作码，缓冲区可以通过 io_uring_register 系统调用进行注册。 内核中将会调用io_sqe_buffers_register，该函数会返回对io_sqe_buffer_register的调用，以此来注册缓冲区。

```
syscall(io_uring_register) -> io_sqe_buffers_register -> io_sqe_buffer_register
```

```
/* io_uring/rsrc.c */
static int io_sqe_buffer_register(struct io_ring_ctx *ctx, struct iovec *iov,
				  struct io_mapped_ubuf **pimu,
				  struct page **last_hpage)
{
	struct io_mapped_ubuf *imu = NULL;
	struct page **pages = NULL; // important to remember: *struct page* refers to physical pages
	unsigned long off;
	size_t size;
	int ret, nr_pages, i;
	struct folio *folio = NULL;

	*pimu = ctx->dummy_ubuf;
	if (!iov->iov_base) // if base is NULL
		return 0;

	ret = -ENOMEM;
	pages = io_pin_pages((unsigned long) iov->iov_base, iov->iov_len,
				&nr_pages); // pins the pages that the iov occupies
	// returns a pointer to an array of *page* pointers 
	// and sets nr_pages to the number of pinned pages
	if (IS_ERR(pages)) {
		ret = PTR_ERR(pages);
		pages = NULL;
		goto done;
	}
    ...
```

### 漏洞函数参数解析

该函数传递四个参数：上下文ctx、iovec 指针iov、io_mapped_ubuf指针的指针pimu和last_hpage指针（该值始终为 NULL）。

* iovec：当我们传递一个要注册的缓冲区时，是以 iovec 的形式传递的。 在此函数中，*iov 指针指向一个结构，其中包含用户要注册的缓冲区的相关信息。

```
struct iovec
{
	void __user *iov_base;	// the address at which the buffer starts
	__kernel_size_t iov_len; // the length of the buffer in bytes
};
```

* io_mapped_ubuf：io_mapped_ubuf 是一种结构，用于保存已注册到 io_uring 实例的缓冲区信息。io_mapped_buf 的最后一个成员是一个 bio_vec 数组。 bio_vec 有点像 iovec，不过是针对物理内存的。 它定义了物理内存地址的连续范围。

```
struct io_mapped_ubuf {
	u64		ubuf; // the address at which the buffer starts
	u64		ubuf_end; // the address at which it ends
	unsigned int	nr_bvecs; // how many bio_vec(s) are needed to address the buffer 
	unsigned long	acct_pages;
	struct bio_vec	bvec[]; // array of bio_vec(s)
};

struct bio_vec {
	struct page	*bv_page; // the first page associated with the address range
	unsigned int	bv_len; // length of the range (in bytes)
	unsigned int	bv_offset; // start of the address range relative to the start of bv_page
};
```

* page：struct page 是一个描述内存物理页的结构。在上面的代码片段中，iov 所跨越的页面被固定在内存中，确保它们留在主内存中，不受分页的影响。 返回的数组 pages 包含指向 iov 所跨结构页的指针，而 nr_pages 则被设置为页数。

### 漏洞函数体解析

* folio：要理解什么是 folio，首先需要了解内核中“page”真正的含义。

通常来说，page 是指内核能够映射的最小物理内存块（通常为 4096 字节，但也可能更大）。不过，在内核上下文中，page 的定义已经被扩展，包含了多个连续 page 组成的复合页面（compound pages），这使得情况更复杂了。

复合页面包含一个“头页面”，存储该复合页面的信息，并标记出复合页面的性质。所有“尾页面”会被标记为 tail，并包含一个指向“头页面”的指针。然而，这会导致一个麻烦的模糊性——如果将一个 tail page 的指针传递给某个函数，那么该函数是应该只作用在该单个页面上，还是在整个复合页面上？

为了解决这种混淆，引入了“page folios”的概念。简单来说，“page folio”是一个保证不为 tail page 的页面。这样一来，旨在处理整个复合页面而非单个 tail page 的函数会接受 `struct *folio` 参数，而不是 `struct *page` 参数，从而消除模糊性。

```
struct folio {
       struct page page;
};
```

结构体 folio 只是 page 的一个包装。需要注意的是，每个 page 都是某个 folio 的一部分。对于非复合页面（non-compound page），其“page folio”就是页面本身。了解了 page folio 后，我们可以分析上面的代码。

```
    ...
	/* 如果是多页，则尝试将它们合并为一个 bvec 条目 */
	if (nr_pages > 1) { // 如果页面数量大于 1
		folio = page_folio(pages[0]); // 将 page 转换为 folio
		// 返回包含此页面的 folio
		for (i = 1; i < nr_pages; i++) {
			if (page_folio(pages[i]) != folio) { // 不同的 folio -> 物理上不连续
				folio = NULL; // 将 folio 设为 NULL，因为无法合并为单一条目
				break;
			}
		}
		if (folio) { // 如果所有页面都在同一个 folio 中
			folio_put_refs(folio, nr_pages - 1); 
			nr_pages = 1; // 将 nr_pages 设为 1，因为可以表示为一个单一的 folio 页面
		}
	}
    ...
```

上述代码的目的是识别被注册的缓冲区所跨越的页面是否属于同一个复合页面。代码会遍历页面并检查它们的 folio 是否相同。如果相同，它将页面数 `nr_pages` 设为 1，并设置 folio 变量。问题就出在这里。

该代码在检查页面是否来自相同的 folio 时，实际上没有验证它们是否连续。它**可能是同一页面被多次映射**。在迭代过程中，`page_folio(page)` 会一次次返回相同的 folio，从而通过检查。这是一个明显的**逻辑漏洞**。接下来我们继续分析 `io_sqe_buffer_register`，看看这个问题会带来什么影响。

```
    ...
	imu = kvmalloc(struct_size(imu, bvec, nr_pages), GFP_KERNEL); 
	// 分配一个包含 nr_pages 个 bio_vec 数组的 imu
	// 需要为每个（物理）页面分配一个 bio_vec
    // 如果是 folio 情况 - bio_vec 数组的大小为 1
	if (!imu)
		goto done;

	ret = io_buffer_account_pin(ctx, pages, nr_pages, imu, last_hpage);
	if (ret) {
		unpin_user_pages(pages, nr_pages);
		goto done;
	}

	off = (unsigned long) iov->iov_base & ~PAGE_MASK;
	size = iov->iov_len; // 将大小设置为用户传入的长度
	/* 存储原始地址以便稍后验证 */
	imu->ubuf = (unsigned long) iov->iov_base; // 用户控制的地址
	imu->ubuf_end = imu->ubuf + iov->iov_len;  // 根据长度计算结束地址
	imu->nr_bvecs = nr_pages;                  // 如果是 folio，则该值为 1
	*pimu = imu;
	ret = 0;

	if (folio) { // 在 folio 情况下 - 只需一个 bio_vec（更高效！）
		bvec_set_page(&imu->bvec[0], pages[0], size, off);
		goto done;
	}
	for (i = 0; i < nr_pages; i++) { 
		size_t vec_len;

		vec_len = min_t(size_t, size, PAGE_SIZE - off);
		bvec_set_page(&imu->bvec[i], pages[i], vec_len, off);
		off = 0;
		size -= vec_len;
	}
done:
	if (ret)
		kvfree(imu);
	kvfree(pages);
	return ret;
}
```

单个 bio_vec 的分配为 nr_pages = 1。 写入 pimu->iov_len 和 pimu->bvec[0].bv_len 的缓冲区大小是用户在 iov->iov_len 中传递的大小。

## 漏洞利用

### 写原语

现在我们来假设，我们正在注册一个跨越多个虚拟页面的缓冲区，但这些页面实际上是同一个页面反复映射出来的。这个缓冲区在虚拟上是连续的，因为虚拟内存是连续的，但在物理上并不连续。当这个缓冲区通过有缺陷的代码检查是否属于一个复合页面时，它会通过，欺骗内核认为它跨越多个页面，作为一个复合页面的一部分，而实际上它只是一个单一页面。

这意味着 pimu->bvec.bv_len 将被设置为缓冲区的虚拟长度，因为内核认为这些虚拟连续的内存是由物理连续的内存支持的。如前所述，bio_vec 处理的是物理内存范围。这个缓冲区会被注册，并使我们可以访问构成该缓冲区的页面之后的物理页面。

我们可以注册一个跨越 n 个虚拟页面但只有一个物理页面的缓冲区。注册此缓冲区后，我们可以使用 io_uring 操作从缓冲区中读取或写入，从而获得对 n-1 个物理页面的越界访问。这里的 n 可以高达允许单个用户态进程映射的页面数上限。因此，我们拥有了一个多页面的越界读写能力。

### 目标对象

由于我们可以对整个物理页面进行 OOB 读写，因此我们对对象本身没有任何限制，我们不关心它们使用的slab、大小或类似的东西。 不过，我们确实有一些要求。 我们需要能够找到目标对象并识别它们。 我们将泄露成千上万页的信息，我们需要能够在大海捞针。 我们需要在对象本身放置一个彩蛋（标识），以便日后识别对象。

