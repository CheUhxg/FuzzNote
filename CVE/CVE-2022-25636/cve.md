# 介绍

|属性|值|
|-|-|
|编号|CVE-2022-25636|
|版本|[v5.4, v5.6.10]|
|目的|UAF+DF|
|参考|[Nick Gregory](https://nickgregory.me/post/2022/03/12/cve-2022-25636/)|

# 概述

netfilter模块中分配的对象数量（少）和迭代访问的数量（多）不匹配，导致OOB写。

# 背景

## netfilter

netfilter是用于**数据包处理**的子组件。
* 支持数据包过滤、网络地址/端口转换（NA[P]T）、数据包日志记录、用户空间数据包队列和其他数据包处理。
* 如iptables和NAT server的实现。

# 原理

## 漏洞点

在函数[nft_fwd_dup_netdev_offload()](https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_dup_netdev.c#L67)中，以ctx->num_actions为下标访问flow->rule->action.entries动态数组时发生越界。
1. 以递增的ctx->num_actions为下标访问数组却**未进行边界检查**。
2. 下标ctx->num_actions和数组flow->rule->action.entries是两个完全不同的变量，没有明显的关联。

```c
int nft_fwd_dup_netdev_offload(struct nft_offload_ctx *ctx,
			       struct nft_flow_rule *flow,
			       enum flow_action_id id, int oif)
{
	struct flow_action_entry *entry;
	struct net_device *dev;

	/* nft_flow_rule_destroy() releases the reference on this device. */
	dev = dev_get_by_index(ctx->net, oif);
	if (!dev)
		return -EOPNOTSUPP;

	entry = &flow->rule->action.entries[ctx->num_actions++];
	entry->id = id;
	entry->dev = dev;

	return 0;
}
```

## 漏洞构造

为了确认这是个bug，需要明确三点：
1. action.entries数组长度是如何定义的？
2. 漏洞发生点nft_fwd_dup_netdev_offload()是如何被调用的？它的调用次数是由什么控制的？
3. ctx是何时被初始化的？如何被初始化的？

发现nft_fwd_dup_netdev_offload()是由一个叫做offload的处理函数调用的，这个offload是[nft_expr_ops](https://elixir.bootlin.com/linux/v5.16.11/C/ident/nft_expr_ops)的成员，而该成员在[nft_flow_rule_create()](https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_tables_offload.c#L125)中被调用。

```c
ctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);

...

while (nft_expr_more(rule, expr)) {
  if (!expr->ops->offload) {
    err = -EOPNOTSUPP;
    goto err_out;
  }
  err = expr->ops->offload(ctx, flow, expr);
  if (err < 0)
    goto err_out;

  expr = nft_expr_next(expr);
}
```

从以上代码中我们可以发现：
1. nft_fwd_dup_netdev_offload在nft_flow_rule_create中被调用。
2. nft_fwd_dup_netdev_offload调用的次数取决于rule中expr的数量（参考[nft_expr_more()](https://elixir.bootlin.com/linux/v5.16.11/source/include/net/netfilter/nf_tables.h#L934)），没有其他的检查。
3. ctx在每次调用nft_flow_rule_create时被以全0初始化（num_actions为0），并将同一个ctx传给每一次nft_fwd_dup_netdev_offload调用。

```c
int num_actions = 0, err;

...

expr = nft_expr_first(rule);
while (nft_expr_more(rule, expr)) {
  if (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)
    num_actions++;

  expr = nft_expr_next(expr);
}

...

flow = nft_flow_rule_alloc(num_actions);
```

从以上代码中可以看到，真正分配给flow的对象数量为num_actions。
* 该变量计算rule中expr->ops->offload_flags为NFT_OFFLOAD_F_ACTION的数量。
* 此时很明显的发现分配给flow的对象数量（数组长度）$\leq$调用nft_fwd_dup_netdev_offload的次数。

回顾之前提到的：每次调用nft_fwd_dup_netdev_offload时，ctx->num_actions会加1。
* 由于调用nft_fwd_dup_netdev_offload的次数不少于数组长度，所以有可能发生OOB写（在nft_fwd_dup_netdev_offload最后对越界对象的id和dev字段执行了写）。

# 利用

```c
entry = &flow->rule->action.entries[ctx->num_actions++];
entry->id = id;
entry->dev = dev;
```

上面提到这个bug提供了2处OOB写：
1. 第一处是*在数组末尾之后立即*向enum flow_action_id写入4或者5（取决于是fwd还是dup）对应的枚举值。
2. 第二处是*在数组末尾之后的第24个字节处*写入结构体net_device指针。

在内核v5.13中，[flow_rule](https://elixir.bootlin.com/linux/v5.16.11/source/include/net/flow_offload.h#L384)结构体大小为32字节，每个entry的大小为80字节。
* 没有entry时，rule大小为32字节，将在kmalloc-32 slab中被分配。
* 有1个entry时，rule大小为112字节，将在kmalloc-128 slab中被分配。
* 有2个entry时，rule大小为192字节，将在kmalloc-192 slab中被分配。
* 以此类推...

针对dev指针的写操作，上述的分配大小意味着写操作将在下一个32或192-slab分配的偏移量24处进行，或者在下一个128-slab分配的偏移量8（24-(128-112)）处进行。
* 如果在规则中设置dup，则可以进行**多次写**。

漏洞利用路径如下：
* 喷射大量System V的消息队列消息，导致内核分配大量大小可控的msg_msg结构体。从现在开始，我们关心在kmalloc-128上的分配。
* 释放一部分上述结构体。
* 添加netlink规则，使得flow_rule被如愿的分配到刚刚释放过的堆内存点上。
* 进行3次OOB写（netlink规则中包含3个dup，没有immediate），攻击
  * 下一条message的list_head.prev指针，偏移量为8。
  * 下一条message的一些随机的数据，偏移量为88。
  * 下面第二条message的security指针，偏移量为40。
* msgrcv接收下面第二条message，导致内核调用kfree()释放net_device。
* 分配更多的message，但这次是在kmalloc-4k slab，为了落到net_device刚刚的位置。
* 让内核触发net_device.netdev_ops指针指向的操作，提供代码执行功能。
  * 作者选择了读取/proc/net/dev，这会导致netdev_ops->ndo_get_stats64被调用。
