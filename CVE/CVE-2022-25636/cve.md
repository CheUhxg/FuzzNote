# 介绍

|属性|值|
|-|-|
|编号|CVE-2022-25636|
|版本|[v5.4, v5.6.10]|
|目的|UAF+DF|
|参考|[Nick Gregory](https://nickgregory.me/post/2022/03/12/cve-2022-25636/)|

# 概述

netfilter模块中分配的对象数量（少）和迭代访问的数量（多）不匹配，导致OOB写。

# 背景

## netfilter

netfilter是用于**数据包处理**的子组件。
* 支持数据包过滤、网络地址/端口转换（NA[P]T）、数据包日志记录、用户空间数据包队列和其他数据包处理。
* 如iptables和NAT server的实现。

# 原理

## 漏洞点

在函数[nft_fwd_dup_netdev_offload()](https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_dup_netdev.c#L67)中，以ctx->num_actions为下标访问flow->rule->action.entries动态数组时发生越界。
1. 以递增的ctx->num_actions为下标访问数组却**未进行边界检查**。
2. 下标ctx->num_actions和数组flow->rule->action.entries是两个完全不同的变量，没有明显的关联。

```c
int nft_fwd_dup_netdev_offload(struct nft_offload_ctx *ctx,
			       struct nft_flow_rule *flow,
			       enum flow_action_id id, int oif)
{
	struct flow_action_entry *entry;
	struct net_device *dev;

	/* nft_flow_rule_destroy() releases the reference on this device. */
	dev = dev_get_by_index(ctx->net, oif);
	if (!dev)
		return -EOPNOTSUPP;

	entry = &flow->rule->action.entries[ctx->num_actions++];
	entry->id = id;
	entry->dev = dev;

	return 0;
}
```

## 漏洞构造

为了确认这是个bug，需要明确三点：
1. action.entries数组长度是如何定义的？
2. 漏洞发生点nft_fwd_dup_netdev_offload()是如何被调用的？它的调用次数是由什么控制的？
3. ctx是何时被初始化的？如何被初始化的？

发现nft_fwd_dup_netdev_offload()是由一个叫做offload的处理函数调用的，这个offload是[nft_expr_ops](https://elixir.bootlin.com/linux/v5.16.11/C/ident/nft_expr_ops)的成员，而该成员在[nft_flow_rule_create()](https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_tables_offload.c#L125)中被调用。

```c
ctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);

...

while (nft_expr_more(rule, expr)) {
  if (!expr->ops->offload) {
    err = -EOPNOTSUPP;
    goto err_out;
  }
  err = expr->ops->offload(ctx, flow, expr);
  if (err < 0)
    goto err_out;

  expr = nft_expr_next(expr);
}
```

从以上代码中我们可以发现：
1. nft_fwd_dup_netdev_offload在nft_flow_rule_create中被调用。
2. nft_fwd_dup_netdev_offload调用的次数取决于rule中expr的数量（参考[nft_expr_more()](https://elixir.bootlin.com/linux/v5.16.11/source/include/net/netfilter/nf_tables.h#L934)），没有其他的检查。
3. ctx在每次调用nft_flow_rule_create时被以全0初始化（num_actions为0），并将同一个ctx传给每一次nft_fwd_dup_netdev_offload调用。

```c
int num_actions = 0, err;

...

expr = nft_expr_first(rule);
while (nft_expr_more(rule, expr)) {
  if (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)
    num_actions++;

  expr = nft_expr_next(expr);
}

...

flow = nft_flow_rule_alloc(num_actions);
```

从以上代码中可以看到，真正分配给flow的对象数量为num_actions。
* 该变量计算rule中expr->ops->offload_flags为NFT_OFFLOAD_F_ACTION的数量。
* 此时很明显的发现分配给flow的对象数量（数组长度）$\leq$调用nft_fwd_dup_netdev_offload的次数。

回顾之前提到的：每次调用nft_fwd_dup_netdev_offload时，ctx->num_actions会加1。
* 由于调用nft_fwd_dup_netdev_offload的次数不少于数组长度，所以有可能发生越界写（在nft_fwd_dup_netdev_offload最后对越界对象的id和dev字段执行了写）。

